services:
  redis:
    image: redis:7.0-alpine
    container_name: ctf-redis
    restart: unless-stopped
    ports: [ "6379:6379" ]
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 10s
    networks: [ ctf-network ]
    # 성능 최적화를 위한 명령어 추가
    command: redis-server --appendonly yes --maxmemory 256mb --maxmemory-policy allkeys-lru

  db:
    image: mysql:8.0
    container_name: ctf-mysql
    restart: unless-stopped
    ports: [ "3306:3306" ]
    environment:
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_DATABASE: ${DB_NAME}
      MYSQL_USER: ${DB_USERNAME}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      # MySQL 8.0 최적화 설정
      MYSQL_INNODB_BUFFER_POOL_SIZE: 256M
      MYSQL_INNODB_LOG_FILE_SIZE: 64M
    volumes:
      # 데이터 지속성을 위한 볼륨 마운트
      - mysql_data:/var/lib/mysql
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "root", "-p${DB_PASSWORD}"]
      interval: 15s
      timeout: 10s
      retries: 5
      start_period: 30s
    networks: [ ctf-network ]
    # 리소스 제한
    deploy:
      resources:
        limits:
          memory: 512M
        reservations:
          memory: 256M

  backend:
    image: ${DOCKER_HUB_USERNAME}/backend:latest
    container_name: ctf-backend
    restart: unless-stopped
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    expose: [ "8080" ]  # 외부 노출 제거, nginx만 접근
    environment:
      # Spring Boot 프로파일 설정
      SPRING_PROFILES_ACTIVE: prod
      
      # 데이터베이스 설정
      DB_HOST: db
      DB_PORT: ${DB_PORT}
      DB_NAME: ${DB_NAME}
      DB_USERNAME: ${DB_USERNAME}
      DB_PASSWORD: ${DB_PASSWORD}
      
      # 보안 설정
      SPRING_SECURITY_USER_NAME: ${SPRING_SECURITY_USER_NAME}
      SPRING_SECURITY_USER_PASSWORD: ${SPRING_SECURITY_USER_PASSWORD}
      JWT_SECRET: ${JWT_SECRET}
      
      # Redis 설정
      SPRING_REDIS_HOST: redis
      SPRING_REDIS_PORT: 6379
      SPRING_REDIS_TIMEOUT: 3000
      
      # 메일 설정
      GMAIL_USERNAME: ${GMAIL_USERNAME}
      GMAIL_APP_PASSWORD: ${GMAIL_APP_PASSWORD}
      
      # API 설정
      API_KEY: ${API_KEY}
      API_URL: ${API_URL}
      
      # GCP 설정
      BUCKET: ${BUCKET}
      LOCATION: ${LOCATION}
      PROJECT_ID: ${PROJECT_ID}
      GCP_JSON_FILE: ${GCP_JSON_FILE}
      GOOGLE_APPLICATION_CREDENTIALS: /secrets/gcp_service_account.json
      
      # JVM 튜닝
      JAVA_OPTS: "-Xmx512m -Xms256m -XX:+UseG1GC -XX:MaxGCPauseMillis=100"
      
      # Spring Boot 설정
      SERVER_PORT: 8080
      MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE: health,metrics,info
      MANAGEMENT_ENDPOINT_HEALTH_SHOW_DETAILS: when-authorized
      
    volumes:
      - ${HOST_GCP_JSON_PATH:-/dev/null}:/secrets/gcp_service_account.json:ro
    networks: [ ctf-network ]
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:8080/actuator/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    # 리소스 제한
    deploy:
      resources:
        limits:
          memory: 768M
        reservations:
          memory: 512M

  frontend:
    image: ${DOCKER_HUB_USERNAME}/frontend:latest
    container_name: ctf-frontend
    restart: unless-stopped
    expose: [ "80" ]
    networks: [ ctf-network ]
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:80 || exit 1"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s
    # 리소스 제한
    deploy:
      resources:
        limits:
          memory: 128M
        reservations:
          memory: 64M

  nginx:
    image: nginx:1.25-alpine
    container_name: ctf-nginx
    restart: unless-stopped
    depends_on:
      backend:
        condition: service_healthy
      frontend:
        condition: service_healthy
    ports:
      - "80:80"
      - "443:443"
    volumes:
      # 설정 파일 (환경변수 사용으로 경로 동적 처리)
      - ${REMOTE_DIR:-./}/nginx/conf.d:/etc/nginx/conf.d:ro
      
      # Let's Encrypt 챌린지용 웹루트
      - ${REMOTE_DIR:-./}/certbot/www:/var/www/certbot:rw
      
      # SSL 인증서
      - ${REMOTE_DIR:-./}/certbot/config:/etc/letsencrypt:rw
      
      # 로그 볼륨 (선택사항)
      - nginx_logs:/var/log/nginx
    networks: [ ctf-network ]
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:80 || exit 1"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s
    # 리소스 제한
    deploy:
      resources:
        limits:
          memory: 64M
        reservations:
          memory: 32M

  # Certbot - on-demand 실행용
  certbot:
    image: certbot/certbot:latest
    container_name: ctf-certbot
    volumes:
      - ${REMOTE_DIR:-./}/certbot/www:/var/www/certbot
      - ${REMOTE_DIR:-./}/certbot/config:/etc/letsencrypt
      - ${REMOTE_DIR:-./}/certbot/logs:/var/log/letsencrypt
    networks: [ ctf-network ]
    # 기본적으로는 sleep 상태 (CI에서 필요할 때만 실행)
    entrypoint: sh
    command: -c "sleep infinity"
    restart: unless-stopped

# 개발/테스트용 서비스들 (프로파일 분리)
  test:
    image: gradle:8.1.1-jdk17
    container_name: ctf-test
    profiles: ["testing"]  # 기본적으로는 실행되지 않음
    working_dir: /app
    volumes:
      - ./Back:/app
      - gradle_cache:/home/gradle/.gradle
    environment:
      SPRING_PROFILES_ACTIVE: test
      DB_HOST: db
      DB_PORT: ${DB_PORT}
      DB_NAME: ${DB_NAME}
      DB_USERNAME: ${DB_USERNAME}
      DB_PASSWORD: ${DB_PASSWORD}
      SPRING_SECURITY_USER_NAME: ${SPRING_SECURITY_USER_NAME}
      SPRING_SECURITY_USER_PASSWORD: ${SPRING_SECURITY_USER_PASSWORD}
      JWT_SECRET: ${JWT_SECRET}
      SPRING_REDIS_HOST: redis
      SPRING_REDIS_PORT: 6379
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    entrypoint: ["sh", "-c"]
    command: ["./gradlew clean test --stacktrace --info"]
    networks: [ ctf-network ]

# 데이터 지속성을 위한 볼륨들
volumes:
  mysql_data:
    driver: local
  nginx_logs:
    driver: local
  gradle_cache:
    driver: local

# 네트워크 설정
networks:
  ctf-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16