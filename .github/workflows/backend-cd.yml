name: Backend & NGINX CD (Auto-SSL)

on:
  push: { branches: [ dev ] }
  workflow_dispatch:

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}

      - name: Build & Push Backend
        run: |
          docker build -t ${{ secrets.DOCKER_HUB_USERNAME }}/backend:latest -f dockerfile .
          docker push ${{ secrets.DOCKER_HUB_USERNAME }}/backend:latest

      # üî• Ïª§Ïä§ÌÖÄ NGINX Ïù¥ÎØ∏ÏßÄÎäî Îçî Ïù¥ÏÉÅ ÎπåÎìúÌïòÏßÄ ÏïäÏäµÎãàÎã§ (Í≥µÏãù Ïù¥ÎØ∏ÏßÄ ÏÇ¨Ïö©).
      # - name: Build & Push NGINX
      #   run: |
      #     docker build -t ${{ secrets.DOCKER_HUB_USERNAME }}/nginx:latest -f nginx/Dockerfile .
      #     docker push ${{ secrets.DOCKER_HUB_USERNAME }}/nginx:latest

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    env:
      DOMAIN:            ${{ secrets.DOMAIN }}
      WWW_DOMAIN:        www.${{ secrets.DOMAIN }}
      LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}
      REMOTE_DIR:        /home/ubuntu/app
    steps:
      - uses: actions/checkout@v4

      # SSH Ï§ÄÎπÑ
      - name: Set up SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SERVER_SSH_KEY }}

      - name: Add host key
        run: |
          ssh-keyscan -H ${{ secrets.SERVER_IP }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Test SSH
        run: ssh -o ConnectTimeout=10 ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} "echo OK"

      # ÏÑúÎ≤Ñ ÎîîÎ†âÌÑ∞Î¶¨ Ï§ÄÎπÑ Î∞è .env ÏÉùÏÑ±
      - name: Prepare remote dirs & .env
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} <<'EOF'
            set -euo pipefail
            sudo mkdir -p '${{ env.REMOTE_DIR }}'/nginx/conf.d \
                           '${{ env.REMOTE_DIR }}'/certbot/{config,www,logs}
            # Ïï± .env
            cat > '${{ env.REMOTE_DIR }}'/.env <<EOT
            DB_NAME=${{ secrets.DB_NAME }}
            DB_USERNAME=${{ secrets.DB_USERNAME }}
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            DB_PORT=${{ secrets.DB_PORT }}
            DOCKER_HUB_USERNAME=${{ secrets.DOCKER_HUB_USERNAME }}
            DOCKER_HUB_ACCESS_TOKEN=${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}
            SPRING_SECURITY_USER_NAME=${{ secrets.SPRING_SECURITY_USER_NAME }}
            SPRING_SECURITY_USER_PASSWORD=${{ secrets.SPRING_SECURITY_USER_PASSWORD }}
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            GMAIL_USERNAME=${{ secrets.GMAIL_USERNAME }}
            GMAIL_APP_PASSWORD=${{ secrets.GMAIL_APP_PASSWORD }}
            API_KEY=${{ secrets.API_KEY }}
            API_URL=${{ secrets.API_URL }}
            BUCKET=${{ secrets.BUCKET }}
            LOCATION=${{ secrets.LOCATION }}
            PROJECT_ID=${{ secrets.PROJECT_ID }}
            GCP_JSON_FILE=${{ secrets.GCP_JSON_FILE }}
            GOOGLE_APPLICATION_CREDENTIALS=/secrets/gcp_service_account.json
            # Nginx/Certbot
            DOMAIN=${{ env.DOMAIN }}
            LETSENCRYPT_EMAIL=${{ env.LETSENCRYPT_EMAIL }}
            # BackendÏö© GCP ÌÇ§ Ìò∏Ïä§Ìä∏ Í≤ΩÎ°ú (composeÏóêÏÑú ÏÇ¨Ïö©)
            HOST_GCP_JSON_PATH=${{ env.REMOTE_DIR }}/gcp_service_account.json
            EOT
          EOF

      # Compose/ÌÖúÌîåÎ¶ø ÏóÖÎ°úÎìú
      - name: Upload docker-compose.yml
        run: scp -o StrictHostKeyChecking=no docker-compose.yml ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }}:${{ env.REMOTE_DIR }}/

      - name: Upload NGINX templates (HTTP/HTTPS)
        run: |
          scp -o StrictHostKeyChecking=no nginx/default.http.conf.template  ${{ secrets.SERVER_USER }}@${{ secrets.Server_IP }}:${{ env.REMOTE_DIR }}/nginx/ 2>/dev/null || \
          scp -o StrictHostKeyChecking=no nginx/default.http.conf.template  ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }}:${{ env.REMOTE_DIR }}/nginx/
          scp -o StrictHostKeyChecking=no nginx/default.https.conf.template ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }}:${{ env.REMOTE_DIR }}/nginx/

      # GCP ÌÇ§ ÌååÏùº(ÏûàÏúºÎ©¥) ÏÑ§Ïπò
      - name: Upload GCP Service Account (optional)
        env:
          GCP_SA: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}
        run: |
          set -euo pipefail
          if [ -z "${GCP_SA:-}" ]; then
            echo "GCP_SERVICE_ACCOUNT_KEY not set. Skipping."
            exit 0
          fi
          if printf '%s' "$GCP_SA" | tr -d '\n' | base64 -d >/dev/null 2>&1; then
            printf '%s' "$GCP_SA" | tr -d '\n' | base64 -d > gcp.json
          else
            printf '%s' "$GCP_SA" > gcp.json
          fi
          scp -o StrictHostKeyChecking=no gcp.json \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }}:${{ env.REMOTE_DIR }}/gcp_service_account.json
          rm -f gcp.json

      # 1) HTTPÎ°ú Î∂ÄÌåÖ (Í≥µÏãù nginx Ïù¥ÎØ∏ÏßÄ ÏÇ¨Ïö© Í∞ÄÏ†ï)
      - name: Start stack (HTTP only)
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} "
            set -euo pipefail
            cd '${{ env.REMOTE_DIR }}' &&
            docker compose down --remove-orphans || true &&
            DOMAIN='${{ env.DOMAIN }}' WWW_DOMAIN='${{ env.WWW_DOMAIN }}' \
              envsubst '\$DOMAIN,\$WWW_DOMAIN' < nginx/default.http.conf.template > nginx/conf.d/default.conf &&
            docker compose pull || true &&
            docker compose up -d nginx backend frontend redis
          "

      - name: Wait for HTTP
        run: |
          for i in $(seq 1 24); do
            if curl -fsS -m 5 -o /dev/null "http://${{ env.DOMAIN }}"; then
              echo "HTTP OK"; exit 0
            fi
            echo "...waiting HTTP ($i/24)"; sleep 5
          done
          exit 1

      # 2) Ïù∏Ï¶ùÏÑú Î∞úÍ∏â/Í∞±Ïã†
      - name: Issue/Renew SSL via certbot
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} "
            set -euo pipefail
            cd '${{ env.REMOTE_DIR }}' &&
            docker compose run --rm certbot certonly \
              --webroot -w /var/www/certbot \
              --non-interactive --keep-until-expiring \
              --email '${{ env.LETSENCRYPT_EMAIL }}' \
              -d '${{ env.DOMAIN }}' -d '${{ env.WWW_DOMAIN }}' \
              --agree-tos --no-eff-email --rsa-key-size 4096
          "

      # 3) HTTPSÎ°ú Ï†ÑÌôò & Î¶¨Î°úÎìú
      - name: Switch to HTTPS & reload NGINX
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} "
            set -euo pipefail
            cd '${{ env.REMOTE_DIR }}' &&
            DOMAIN='${{ env.DOMAIN }}' WWW_DOMAIN='${{ env.WWW_DOMAIN }}' \
              envsubst '\$DOMAIN,\$WWW_DOMAIN' < nginx/default.https.conf.template > nginx/conf.d/default.conf &&
            docker compose exec -T nginx nginx -t &&
            docker compose exec -T nginx nginx -s reload
          "

      - name: Verify HTTPS (apex & www)
        run: |
          for host in "${{ env.DOMAIN }}" "${{ env.WWW_DOMAIN }}"; do
            for i in $(seq 1 12); do
              if curl -fsS -m 5 -o /dev/null "https://$host"; then
                echo "HTTPS OK: $host"; break
              fi
              [ "$i" -eq 12 ] && { echo "HTTPS failed for $host" >&2; exit 1; }
              echo "...waiting HTTPS $host ($i/12)"; sleep 10
            done
          done

      - name: Prune old images
        run: ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} "docker image prune -f --filter 'until=24h' || true"
