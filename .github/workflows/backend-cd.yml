name: Backend & NGINX CD (Auto-SSL)

on:
  push: { branches: [ dev ] }
  workflow_dispatch:

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}

      - name: Build & Push Backend
        run: |
          docker build -t ${{ secrets.DOCKER_HUB_USERNAME }}/backend:latest -f dockerfile .
          docker push ${{ secrets.DOCKER_HUB_USERNAME }}/backend:latest

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    env:
      DOMAIN:            ${{ secrets.DOMAIN }}               # 예: msg.xn--3e0b707e (퓨니코드 권장)
      WWW_DOMAIN:        www.${{ secrets.DOMAIN }}           # 예: www.msg.xn--3e0b707e
      LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}
      REMOTE_DIR:        /home/ubuntu/app
      REMOTE_HOST:       ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }}
      REMOTE_IP:         ${{ secrets.SERVER_IP }}

    steps:
      - uses: actions/checkout@v4

      # SSH 준비
      - name: Set up SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SERVER_SSH_KEY }}

      - name: Add host key
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.SERVER_IP }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Test SSH
        run: ssh -o ConnectTimeout=10 "$REMOTE_HOST" "echo OK"

      # 원격 docker compose v2 보장 (있으면 패스)
      - name: Ensure docker compose v2 on remote
        continue-on-error: true
        run: |
          ssh "$REMOTE_HOST" <<'EOSSH'
            set -Eeuo pipefail
            if sudo docker compose version >/dev/null 2>&1; then
              echo "docker compose v2 already present"
              exit 0
            fi
            sudo apt-get update -y
            if ! sudo apt-get install -y docker-compose-plugin; then
              sudo apt-get install -y curl
              ARCH="$(uname -m)"
              case "$ARCH" in
                x86_64|amd64) ARCH="x86_64" ;;
                aarch64|arm64) ARCH="aarch64" ;;
                *) ARCH="x86_64" ;;
              esac
              sudo install -m 0755 -d /usr/local/lib/docker/cli-plugins
              sudo curl -fsSL "https://github.com/docker/compose/releases/download/v2.30.3/docker-compose-linux-$ARCH" \
                -o /usr/local/lib/docker/cli-plugins/docker-compose
              sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
            fi
            sudo docker compose version
            echo "docker compose v2 installed"
          EOSSH

      # Docker 데몬 기동 보장
      - name: Ensure Docker service is running
        run: |
          ssh "$REMOTE_HOST" <<'EOSSH'
            set -euo pipefail
            sudo systemctl enable --now docker || sudo service docker start
            sudo docker info >/dev/null
          EOSSH

      # 원격 디렉터리만 준비 (여기서는 .env 생성 안 함)
      - name: Prepare remote dirs (no .env here)
        run: |
          ssh "$REMOTE_HOST" <<'EOSSH'
            set -euo pipefail
            REMOTE_DIR='${{ env.REMOTE_DIR }}'

            # envsubst 설치
            if ! command -v envsubst >/dev/null 2>&1; then
              sudo apt-get update -y
              sudo apt-get install -y gettext-base
            fi

            # 디렉터리
            sudo mkdir -p "$REMOTE_DIR/nginx/conf.d" \
                         "$REMOTE_DIR/certbot/config" \
                         "$REMOTE_DIR/certbot/www" \
                         "$REMOTE_DIR/certbot/logs"
          EOSSH

      # 로컬에서 .env 생성 → 업로드 (VITE/CRA 프론트 변수 포함)
      - name: Build .env locally and upload
        env:
          VITE_API_URL_SECRET: ${{ secrets.VITE_API_URL }}           # (선택)
          REACT_APP_API_URL_SECRET: ${{ secrets.REACT_APP_API_URL }} # (선택)
        run: |
          set -euo pipefail

          VITE_URL="${VITE_API_URL_SECRET:-}"
          REACT_URL="${REACT_APP_API_URL_SECRET:-}"
          [ -z "$VITE_URL" ] && VITE_URL="https://${{ env.DOMAIN }}"
          [ -z "$REACT_URL" ] && REACT_URL="https://${{ env.DOMAIN }}"

          # 1) 여기문을 'EOF'로 인용 → 시크릿 내부의 $ 확장 방지
          cat > .env.ci <<'EOF'
          DB_NAME=${{ secrets.DB_NAME }}
          DB_USERNAME=${{ secrets.DB_USERNAME }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_PORT=${{ secrets.DB_PORT }}
          DOCKER_HUB_USERNAME=${{ secrets.DOCKER_HUB_USERNAME }}
          DOCKER_HUB_ACCESS_TOKEN=${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}
          SPRING_SECURITY_USER_NAME=${{ secrets.SPRING_SECURITY_USER_NAME }}
          SPRING_SECURITY_USER_PASSWORD=${{ secrets.SPRING_SECURITY_USER_PASSWORD }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          GMAIL_USERNAME=${{ secrets.GMAIL_USERNAME }}
          GMAIL_APP_PASSWORD=${{ secrets.GMAIL_APP_PASSWORD }}
          API_KEY=${{ secrets.API_KEY }}
          API_URL=${{ secrets.API_URL }}
          BUCKET=${{ secrets.BUCKET }}
          LOCATION=${{ secrets.LOCATION }}
          PROJECT_ID=${{ secrets.PROJECT_ID }}
          GCP_JSON_FILE=${{ secrets.GCP_JSON_FILE }}
          GOOGLE_APPLICATION_CREDENTIALS=/secrets/gcp_service_account.json

          # --- Domains (as provided) ---
          DOMAIN=${{ env.DOMAIN }}
          WWW_DOMAIN=${{ env.WWW_DOMAIN }}
          LETSENCRYPT_EMAIL=${{ env.LETSENCRYPT_EMAIL }}

          # --- Paths ---
          HOST_GCP_JSON_PATH=${{ env.REMOTE_DIR }}/gcp_service_account.json

          # --- derived (do not edit manually) ---
          FRONTEND_ORIGIN=https://${{ env.DOMAIN }}
          CORS_ALLOWED_ORIGINS=https://${{ env.DOMAIN }},https://${{ env.WWW_DOMAIN }}
          SPRING_WEB_CORS_ALLOWED_ORIGINS=https://${{ env.DOMAIN }},https://${{ env.WWW_DOMAIN }}
          EOF

          # 2) 동적으로 필요한 라인만 안전하게 추가 (여기서 변수 확장)
          {
            printf '\n# --- frontend runtime variables ---\n'
            printf 'VITE_API_URL=%s\n' "$VITE_URL"
            printf 'REACT_APP_API_URL=%s\n' "$REACT_URL"
          } >> .env.ci

          # 3) 업로드
          scp -o StrictHostKeyChecking=no .env.ci "$REMOTE_HOST":/tmp/.env
          ssh "$REMOTE_HOST" "sudo mv /tmp/.env '${{ env.REMOTE_DIR }}/.env' && sudo chown root:root '${{ env.REMOTE_DIR }}/.env' && sudo chmod 600 '${{ env.REMOTE_DIR }}/.env'"

      # 업로드는 /tmp → sudo mv (권한 안전)
      - name: Upload docker-compose.yml via /tmp
        run: |
          scp -o StrictHostKeyChecking=no docker-compose.yml "$REMOTE_HOST":/tmp/docker-compose.yml
          ssh "$REMOTE_HOST" "sudo mv /tmp/docker-compose.yml '${{ env.REMOTE_DIR }}/docker-compose.yml'"

      - name: Upload NGINX templates via /tmp
        run: |
          scp -o StrictHostKeyChecking=no nginx/default.http.conf.template  "$REMOTE_HOST":/tmp/default.http.conf.template
          scp -o StrictHostKeyChecking=no nginx/default.https.conf.template "$REMOTE_HOST":/tmp/default.https.conf.template
          ssh "$REMOTE_HOST" "
            sudo mv /tmp/default.http.conf.template  '${{ env.REMOTE_DIR }}/nginx/default.http.conf.template';
            sudo mv /tmp/default.https.conf.template '${{ env.REMOTE_DIR }}/nginx/default.https.conf.template';
          "

      # (옵션) GCP 키 업로드
      - name: Upload GCP Service Account (optional)
        env:
          GCP_SA: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}
        run: |
          set -euo pipefail
          if [ -z "${GCP_SA:-}" ]; then
            echo "GCP_SERVICE_ACCOUNT_KEY not set. Skipping."
            exit 0
          fi
          if printf '%s' "$GCP_SA" | tr -d '\n' | base64 -d >/dev/null 2>&1; then
            printf '%s' "$GCP_SA" | tr -d '\n' | base64 -d > gcp.json
          else
            printf '%s' "$GCP_SA" > gcp.json
          fi
          scp -o StrictHostKeyChecking=no gcp.json "$REMOTE_HOST":/tmp/gcp.json
          ssh "$REMOTE_HOST" "sudo mv /tmp/gcp.json '${{ env.REMOTE_DIR }}/gcp_service_account.json'"
          rm -f gcp.json

      # 1) HTTP 기동 (템플릿 치환은 기존 변수명 사용)
      - name: Start stack (HTTP only)
        run: |
          ssh "$REMOTE_HOST" bash -s <<'EOSSH'
            set -euo pipefail
            cd '${{ env.REMOTE_DIR }}'

            DOMAIN='${{ env.DOMAIN }}' WWW_DOMAIN='${{ env.WWW_DOMAIN }}' \
              envsubst '\$DOMAIN,\$WWW_DOMAIN' < nginx/default.http.conf.template \
              | sudo tee nginx/conf.d/default.conf >/dev/null

            sudo docker compose down --remove-orphans || true
            sudo docker compose pull || true
            sudo docker compose up -d nginx backend frontend redis
          EOSSH

      - name: Wait for HTTP (apex & www)
        run: |
          for HOST in "${{ env.DOMAIN }}" "${{ env.WWW_DOMAIN }}"; do
            echo "Waiting for http://$HOST"
            for i in $(seq 1 24); do
              if curl -fsS -m 5 -o /dev/null "http://$HOST"; then
                echo "HTTP OK: $HOST"; break
              fi
              [ "$i" -eq 24 ] && { echo "HTTP failed: $HOST"; exit 1; }
              echo "...waiting HTTP ($i/24)"; sleep 5
            done
          done

      # (선택) ACME 프리플라이트
      - name: ACME preflight (HTTP-01 reachability)
        run: |
          set -euo pipefail
          TOKEN="$(openssl rand -hex 16)"

          ssh "$REMOTE_HOST" "
            set -euo pipefail
            REMOTE_DIR='${{ env.REMOTE_DIR }}'
            sudo mkdir -p \"\$REMOTE_DIR/certbot/www/.well-known/acme-challenge\"
            echo \"$TOKEN\" | sudo tee \"\$REMOTE_DIR/certbot/www/.well-known/acme-challenge/$TOKEN\" >/dev/null
          "

          for host in "${{ env.DOMAIN }}" "${{ env.WWW_DOMAIN }}"; do
            echo "Check: http://$host/.well-known/acme-challenge/$TOKEN"
            body="$(curl -fsS -m 8 "http://$host/.well-known/acme-challenge/$TOKEN" || true)"
            if [ "$body" != "$TOKEN" ]; then
              echo "❌ ACME path unreachable for $host"
              echo "   Expected: $TOKEN"
              echo "   Got: ${body:0:120}..."
              exit 1
            else
              echo "✅ OK for $host"
            fi
          done

      # 2) 인증서 발급/갱신
      - name: Issue/Renew SSL via certbot
        run: |
          ssh "$REMOTE_HOST" bash -s <<'EOSSH'
            set -euo pipefail
            cd '${{ env.REMOTE_DIR }}'

            sudo docker compose run --rm --entrypoint certbot certbot \
              certonly \
              --webroot -w /var/www/certbot \
              --non-interactive --keep-until-expiring \
              --email '${{ env.LETSENCRYPT_EMAIL }}' \
              -d '${{ env.DOMAIN }}' -d '${{ env.WWW_DOMAIN }}' \
              --agree-tos --no-eff-email --rsa-key-size 4096
          EOSSH

      # 3) HTTPS 전환 & 리로드
      - name: Apply HTTPS config & reload nginx
        run: |
          ssh "$REMOTE_HOST" bash -s <<'EOSSH'
            set -euo pipefail
            cd '${{ env.REMOTE_DIR }}'

            DOMAIN='${{ env.DOMAIN }}' WWW_DOMAIN='${{ env.WWW_DOMAIN }}' \
              envsubst '\$DOMAIN,\$WWW_DOMAIN' < nginx/default.https.conf.template \
              | sudo tee nginx/conf.d/default.conf >/dev/null

            sudo docker compose exec -T nginx nginx -t
            sudo docker compose exec -T nginx nginx -s reload
          EOSSH

      # 4-1) 서버 내부에서 HTTPS 자체검증
            - name: Remote self-check HTTPS (bind to localhost with SNI)
        run: |
          ssh "$REMOTE_HOST" bash -s <<'EOSSH'
            set -euo pipefail
            cd '${{ env.REMOTE_DIR }}'

            echo "== nginx container status =="
            sudo docker compose ps nginx || true

            echo "== inside nginx: ports =="
            sudo docker compose exec -T nginx sh -lc "ss -lntp | awk 'NR==1 || /:80|:443/'" || true

            for h in '${{ env.DOMAIN }}' '${{ env.WWW_DOMAIN }}'; do
              echo "Localhost HTTPS check with SNI: https://$h (-> 127.0.0.1:443)"
              if ! curl -fsS -m 10 -o /dev/null --resolve "$h:443:127.0.0.1" "https://$h"; then
                echo "❌ Localhost HTTPS failed for $h"
                echo "== recent nginx logs =="
                sudo docker compose logs --tail=120 nginx || true
                echo "== nginx -t output =="
                sudo docker compose exec -T nginx nginx -t || true
                echo "== certs listing =="
                sudo docker compose exec -T nginx sh -lc "ls -l /etc/letsencrypt/live || true; ls -l /etc/letsencrypt/archive || true"
                exit 1
              else
                echo "✅ Localhost HTTPS OK for $h"
              fi
            done
          EOSSH


      # 4-2) 러너에서 서버 공인 IPv4로 SNI 고정 검증
      - name: Verify HTTPS from runner via fixed IP (SNI/Host forced)
        run: |
          set -e
          for host in "${{ env.DOMAIN }}" "${{ env.WWW_DOMAIN }}"; do
            echo "Runner check: https://$host via ${{ env.REMOTE_IP }}"
            for i in $(seq 1 15); do
              if curl -fsS -m 8 --resolve "$host:443:${{ env.REMOTE_IP }}" "https://$host" -o /dev/null; then
                echo "HTTPS OK (runner via fixed IP): $host"; break
              fi
              [ "$i" -eq 15 ] && { echo "Runner check failed for $host"; exit 1; }
              echo "...retry $i/15"; sleep 2
            done
          done

      - name: Prune old images
        run: ssh "$REMOTE_HOST" "sudo docker image prune -f --filter 'until=24h' || true"
