name: Backend & NGINX CD (Auto-SSL)

on:
  push: { branches: [ dev ] }
  workflow_dispatch:

concurrency:
  group: backend-nginx-cd-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}

      - name: Build & Push Backend
        run: |
          set -euo pipefail
          DF="Dockerfile"; [ -f dockerfile ] && DF="dockerfile"
          IMAGE="${{ secrets.DOCKER_HUB_USERNAME }}/backend"
          TAG_SHA="${{ github.sha }}"
          docker build -t "${IMAGE}:${TAG_SHA}" -t "${IMAGE}:latest" -f "$DF" .
          docker push "${IMAGE}:${TAG_SHA}"
          docker push "${IMAGE}:latest"

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    env:
      DOMAIN:            ${{ secrets.DOMAIN }}
      WWW_DOMAIN:        www.${{ secrets.DOMAIN }}
      LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}
      REMOTE_DIR:        /home/ubuntu/app
      REMOTE_HOST:       ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }}
      REMOTE_IP:         ${{ secrets.SERVER_IP }}
      IMAGE_TAG:         ${{ github.sha }}

    steps:
      - uses: actions/checkout@v4

      - name: Set up SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SERVER_SSH_KEY }}

      - name: Add host key
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.SERVER_IP }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Test SSH
        run: ssh -o ConnectTimeout=10 "$REMOTE_HOST" "echo OK"

      - name: Ensure docker compose v2 on remote
        continue-on-error: true
        run: |
          ssh "$REMOTE_HOST" <<'EOSSH'
            set -Eeuo pipefail
            if sudo docker compose version >/dev/null 2>&1; then
              echo "docker compose v2 already present"; exit 0
            fi
            sudo apt-get update -y
            if ! sudo apt-get install -y docker-compose-plugin; then
              sudo apt-get install -y curl
              ARCH="$(uname -m)"
              case "$ARCH" in
                x86_64|amd64) ARCH="x86_64" ;;
                aarch64|arm64) ARCH="aarch64" ;;
                *) ARCH="x86_64" ;;
              esac
              sudo install -m 0755 -d /usr/local/lib/docker/cli-plugins
              sudo curl -fsSL "https://github.com/docker/compose/releases/download/v2.30.3/docker-compose-linux-$ARCH" \
                -o /usr/local/lib/docker/cli-plugins/docker-compose
              sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
            fi
            sudo docker compose version
            echo "docker compose v2 installed"
          EOSSH

      - name: Ensure Docker service is running
        run: |
          ssh "$REMOTE_HOST" <<'EOSSH'
            set -euo pipefail
            sudo systemctl enable --now docker || sudo service docker start
            sudo docker info >/dev/null
          EOSSH

      - name: Prepare remote dirs (no .env here)
        run: |
          ssh "$REMOTE_HOST" <<'EOSSH'
            set -euo pipefail
            REMOTE_DIR='${{ env.REMOTE_DIR }}'
            if ! command -v envsubst >/dev/null 2>&1; then
              sudo apt-get update -y
              sudo apt-get install -y gettext-base
            fi
            sudo mkdir -p "$REMOTE_DIR/nginx/conf.d" \
                         "$REMOTE_DIR/certbot/config" \
                         "$REMOTE_DIR/certbot/www/.well-known/acme-challenge" \
                         "$REMOTE_DIR/certbot/logs"
          EOSSH

      - name: Build .env locally and upload
        env:
          VITE_API_URL_SECRET: ${{ secrets.VITE_API_URL }}
          REACT_APP_API_URL_SECRET: ${{ secrets.REACT_APP_API_URL }}
        run: |
          set -euo pipefail
          VITE_URL="${VITE_API_URL_SECRET:-https://${{ env.DOMAIN }}}"
          REACT_URL="${REACT_APP_API_URL_SECRET:-https://${{ env.DOMAIN }}}"

          cat > .env.ci <<'EOF'
          DB_NAME=${{ secrets.DB_NAME }}
          DB_USERNAME=${{ secrets.DB_USERNAME }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_PORT=${{ secrets.DB_PORT }}
          DOCKER_HUB_USERNAME=${{ secrets.DOCKER_HUB_USERNAME }}
          DOCKER_HUB_ACCESS_TOKEN=${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}
          SPRING_SECURITY_USER_NAME=${{ secrets.SPRING_SECURITY_USER_NAME }}
          SPRING_SECURITY_USER_PASSWORD=${{ secrets.SPRING_SECURITY_USER_PASSWORD }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          GMAIL_USERNAME=${{ secrets.GMAIL_USERNAME }}
          GMAIL_APP_PASSWORD=${{ secrets.GMAIL_APP_PASSWORD }}
          API_KEY=${{ secrets.API_KEY }}
          API_URL=${{ secrets.API_URL }}
          BUCKET=${{ secrets.BUCKET }}
          LOCATION=${{ secrets.LOCATION }}
          PROJECT_ID=${{ secrets.PROJECT_ID }}
          GCP_JSON_FILE=${{ secrets.GCP_JSON_FILE }}
          GOOGLE_APPLICATION_CREDENTIALS=/secrets/gcp_service_account.json

          DOMAIN=${{ env.DOMAIN }}
          WWW_DOMAIN=${{ env.WWW_DOMAIN }}
          LETSENCRYPT_EMAIL=${{ env.LETSENCRYPT_EMAIL }}

          HOST_GCP_JSON_PATH=${{ env.REMOTE_DIR }}/gcp_service_account.json

          FRONTEND_ORIGIN=https://${{ env.DOMAIN }}
          CORS_ALLOWED_ORIGINS=https://${{ env.DOMAIN }},https://${{ env.WWW_DOMAIN }}
          SPRING_WEB_CORS_ALLOWED_ORIGINS=https://${{ env.DOMAIN }},https://${{ env.WWW_DOMAIN }}
          IMAGE_TAG=${{ env.IMAGE_TAG }}

          # >>> GCP Storage(Spring)
          SPRING_CLOUD_GCP_STORAGE_CREDENTIALS_LOCATION=file:/secrets/gcp_service_account.json
          SPRING_CLOUD_GCP_STORAGE_BUCKET=${{ secrets.BUCKET }}

          # >>> Discord alert bot (prod)
          CTF_ALERT_ENABLED=true
          CTF_ALERT_ENDPOINT=${{ secrets.CTF_ALERT_ENDPOINT }}
          CTF_ALERT_API_KEY=${{ secrets.CTF_ALERT_API_KEY }}
          CTF_ALERT_ENVIRONMENT=prod
          EOF

          {
            printf '\n# --- frontend runtime variables ---\n'
            printf 'VITE_API_URL=%s\n' "$VITE_URL"
            printf 'REACT_APP_API_URL=%s\n' "$REACT_URL"
          } >> .env.ci

          scp -o StrictHostKeyChecking=no .env.ci "$REMOTE_HOST":/tmp/.env
          ssh "$REMOTE_HOST" "sudo mv /tmp/.env '${{ env.REMOTE_DIR }}/.env' && sudo chown root:root '${{ env.REMOTE_DIR }}/.env' && sudo chmod 600 '${{ env.REMOTE_DIR }}/.env'"

      - name: Upload docker-compose.yml via /tmp
        run: |
          scp -o StrictHostKeyChecking=no docker-compose.yml "$REMOTE_HOST":/tmp/docker-compose.yml
          ssh "$REMOTE_HOST" "sudo mv /tmp/docker-compose.yml '${{ env.REMOTE_DIR }}/docker-compose.yml'"

      - name: Upload NGINX templates via /tmp
        run: |
          scp -o StrictHostKeyChecking=no nginx/default.http.conf.template  "$REMOTE_HOST":/tmp/default.http.conf.template
          scp -o StrictHostKeyChecking=no nginx/default.https.conf.template "$REMOTE_HOST":/tmp/default.https.conf.template
          ssh "$REMOTE_HOST" "
            sudo mv /tmp/default.http.conf.template  '${{ env.REMOTE_DIR }}/nginx/default.http.conf.template';
            sudo mv /tmp/default.https.conf.template '${{ env.REMOTE_DIR }}/nginx/default.https.conf.template';
          "

      # ðŸ”¹ limit_zone ì „ì—­(í•œ ê³³) ì„ ì–¸
      - name: Install NGINX limit zones (00-limits.conf)
        run: |
          ssh "$REMOTE_HOST" <<'EOSSH'
            set -euo pipefail
            sudo install -d -m 0755 /home/ubuntu/app/nginx/conf.d
            CONF=/home/ubuntu/app/nginx/conf.d/00-limits.conf

            # ìž„ì‹œ íŒŒì¼ë¡œ ë¨¼ì € ì“´ ë’¤ êµì²´(ë¶€ë¶„ì“°ê¸°/ê¹¨ì§ ë°©ì§€)
            sudo tee "${CONF}.tmp" >/dev/null <<'CONF'
            limit_conn_zone $binary_remote_addr zone=conn_per_ip:10m;
            limit_req_zone  $binary_remote_addr zone=api_per_ip:10m rate=10r/s;
            limit_req_zone  $binary_remote_addr$uri zone=api_per_ip_uri:10m rate=5r/s;
            CONF

            # CRLF ì œê±° í›„ ì†Œìœ ê¶Œ/ê¶Œí•œ ì •ë¦¬, ì›ìž êµì²´
            sudo sed -i 's/\r$//' "${CONF}.tmp"
            sudo chown root:root "${CONF}.tmp"
            sudo chmod 0644 "${CONF}.tmp"
            sudo mv -f "${CONF}.tmp" "${CONF}"

            # ë‚´ìš© ê²€ì¦(ì˜¤íƒ€ ë°©ì§€ìš©)
            echo '--- 00-limits.conf ---'
            sudo nl -ba "${CONF}"
            # ìž˜ëª»ëœ íŒ¨í„´ì´ ë‚¨ì•„ìžˆìœ¼ë©´ ì‹¤íŒ¨ì‹œì¼œ ìž¬ë°œ ë°©ì§€
            if sudo grep -n 'zone=api_per_ip:10r/s' "${CONF}"; then
              echo '[FATAL] zone=api_per_ip:10r/s ë°œê²¬ë¨ â†’ 10m ì´ì–´ì•¼ í•©ë‹ˆë‹¤.' >&2
              exit 1
            fi
          EOSSH

      - name: Upload GCP Service Account (place before backend restart)
        env:
          GCP_SA: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}
        run: |
          set -euo pipefail
          if [ -z "${GCP_SA:-}" ]; then
            echo "GCP_SERVICE_ACCOUNT_KEY not set. Skipping."
          else
            if printf '%s' "$GCP_SA" | tr -d '\n' | base64 -d >/dev/null 2>&1; then
              printf '%s' "$GCP_SA" | tr -d '\n' | base64 -d > gcp.json
            else
              printf '%s' "$GCP_SA" > gcp.json
            fi
            scp -o StrictHostKeyChecking=no gcp.json "$REMOTE_HOST":/tmp/gcp.json
            ssh "$REMOTE_HOST" "sudo mv /tmp/gcp.json '${{ env.REMOTE_DIR }}/gcp_service_account.json'"
            rm -f gcp.json
          fi

      - name: Update backend image (pull + recreate)
        run: |
          ssh "$REMOTE_HOST" <<'EOSSH'
            set -euo pipefail
            cd '${{ env.REMOTE_DIR }}'
            sudo docker compose pull backend
            sudo docker compose up -d --no-deps --pull always backend
            echo "Running backend image:"
            sudo docker inspect $(sudo docker compose ps -q backend) --format '{{.Config.Image}}'
          EOSSH

      - name: Start stack (HTTP only)
        run: |
          ssh "$REMOTE_HOST" <<'EOSSH'
            set -euo pipefail
            cd '${{ env.REMOTE_DIR }}'
            sudo docker compose up -d nginx backend frontend redis || true
            sudo docker compose exec nginx sh -lc '
              set -e
              envsubst '\''$DOMAIN $WWW_DOMAIN'\'' < /etc/nginx/templates/default.http.conf.template > /etc/nginx/conf.d/default.conf
              sed -i "/^[[:space:]]*limit_\\(conn\\|req\\)_zone/d" /etc/nginx/conf.d/default.conf
              nginx -t || { echo "[!] nginx -t failed, dump head:"; nginx -T | sed -n \"1,200p\"; exit 1; }
              nginx -s reload
              echo "Reloaded (HTTP)"
            '
          EOSSH

      - name: Wait for HTTP (via fixed IP)
        run: |
          set -euo pipefail
          APEX="${{ env.DOMAIN }}"; WWW="${{ env.WWW_DOMAIN }}"; IP="${{ env.REMOTE_IP }}"
          echo "Waiting for http://${APEX} via ${IP}"
          ok=0
          for i in $(seq 1 24); do
            if curl -fsS -m 6 --resolve "${APEX}:80:${IP}" "http://${APEX}" -o /dev/null; then
              echo "HTTP OK (apex)"; ok=1; break
            fi
            echo "...waiting HTTP ($i/24)"; sleep 5
          done
          [ "$ok" -eq 1 ] || { echo "HTTP failed (apex via IP)"; exit 1; }
          if curl -fsS -m 6 --resolve "${WWW}:80:${IP}" "http://${WWW}" -o /dev/null; then
            echo "HTTP OK (www)"
          else
            echo "WWW not reachable via IP (might be no DNS)."
          fi

      - name: Issue/Renew SSL via certbot
        run: |
          ssh "$REMOTE_HOST" <<'EOSSH'
            set -euo pipefail
            cd '${{ env.REMOTE_DIR }}'
            sudo docker compose run --rm --entrypoint certbot certbot \
              certonly \
              --webroot -w /var/www/certbot \
              --non-interactive --keep-until-expiring \
              --email '${{ env.LETSENCRYPT_EMAIL }}' \
              -d '${{ env.DOMAIN }}' -d '${{ env.WWW_DOMAIN }}' \
              --agree-tos --no-eff-email --rsa-key-size 4096
          EOSSH

      - name: Apply HTTPS config & reload nginx
        run: |
          ssh "$REMOTE_HOST" <<'EOSSH'
            set -euo pipefail
            cd '${{ env.REMOTE_DIR }}'
            sudo docker compose exec nginx sh -lc '
              set -e
              envsubst '\''$DOMAIN $WWW_DOMAIN'\'' < /etc/nginx/templates/default.https.conf.template > /etc/nginx/conf.d/default.conf
              sed -i "/^[[:space:]]*limit_\\(conn\\|req\\)_zone/d" /etc/nginx/conf.d/default.conf
              nginx -t || { echo "[!] nginx -t failed, dump head:"; nginx -T | sed -n \"1,200p\"; exit 1; }
              nginx -s reload
              echo "Reloaded (HTTPS)"
              echo "=== /etc/nginx/conf.d/00-limits.conf ==="
              nl -ba /etc/nginx/conf.d/00-limits.conf || true
            '
            sudo docker compose logs nginx --tail=50
          EOSSH

      - name: Verify HTTPS (apex & www via fixed IP)
        run: |
          set -euo pipefail
          IP="${{ env.REMOTE_IP }}"
          for host in "${{ env.DOMAIN }}" "${{ env.WWW_DOMAIN }}"; do
            echo "Check https://$host via $IP"
            ok=0
            for i in $(seq 1 12); do
              if curl -fsS -m 8 --resolve "$host:443:${IP}" "https://$host" -o /dev/null; then
                echo "HTTPS OK: $host"; ok=1; break
              fi
              echo "...waiting HTTPS $host ($i/12)"; sleep 5
            done
            [ "$ok" -eq 1 ] || { echo "HTTPS failed for $host (via IP)"; exit 1; }
          done

      - name: Prune old images
        run: ssh "$REMOTE_HOST" "sudo docker image prune -f --filter 'until=24h' || true"
