name: Backend & NGINX CD (Auto-SSL)

on:
  push: { branches: [ dev ] }
  workflow_dispatch:

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}

      - name: Build & Push Backend
        run: |
          docker build -t ${{ secrets.DOCKER_HUB_USERNAME }}/backend:latest -f dockerfile .
          docker push ${{ secrets.DOCKER_HUB_USERNAME }}/backend:latest

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    env:
      DOMAIN:            ${{ secrets.DOMAIN }}
      WWW_DOMAIN:        www.${{ secrets.DOMAIN }}
      LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}
      REMOTE_DIR:        /home/ubuntu/app
      REMOTE_HOST:       ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }}
      REMOTE_IP:         ${{ secrets.SERVER_IP }}

    steps:
      - uses: actions/checkout@v4

      # SSH 준비
      - name: Set up SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SERVER_SSH_KEY }}

      - name: Add host key
        run: ssh-keyscan -H ${{ secrets.SERVER_IP }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Test SSH
        run: ssh -o ConnectTimeout=10 "$REMOTE_HOST" "echo OK"

      # 원격 docker compose v2 보장 (있으면 패스)
      - name: Ensure docker compose v2 on remote
        continue-on-error: true
        run: |
          ssh "$REMOTE_HOST" <<'EOSSH'
            set -Eeuo pipefail
            if sudo docker compose version >/dev/null 2>&1; then
              echo "docker compose v2 already present"
              exit 0
            fi
            sudo apt-get update -y
            if ! sudo apt-get install -y docker-compose-plugin; then
              sudo apt-get install -y curl
              ARCH="$(uname -m)"
              case "$ARCH" in
                x86_64|amd64) ARCH="x86_64" ;;
                aarch64|arm64) ARCH="aarch64" ;;
                *) ARCH="x86_64" ;;
              esac
              sudo install -m 0755 -d /usr/local/lib/docker/cli-plugins
              sudo curl -fsSL "https://github.com/docker/compose/releases/download/v2.30.3/docker-compose-linux-$ARCH" \
                -o /usr/local/lib/docker/cli-plugins/docker-compose
              sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
            fi
            sudo docker compose version
            echo "docker compose v2 installed"
          EOSSH

      # Docker 데몬 기동 보장
      - name: Ensure Docker service is running
        run: |
          ssh "$REMOTE_HOST" <<'EOSSH'
            set -euo pipefail
            sudo systemctl enable --now docker || sudo service docker start
            sudo docker info >/dev/null
          EOSSH

      # 필수 디렉터리 + .env 생성
      - name: Prepare remote dirs & .env
        run: |
          ssh "$REMOTE_HOST" <<'EOF'
            set -euo pipefail
            REMOTE_DIR='${{ env.REMOTE_DIR }}'

            # envsubst 설치
            if ! command -v envsubst >/dev/null 2>&1; then
              sudo apt-get update -y
              sudo apt-get install -y gettext-base
            fi

            # 디렉터리 (root 소유)
            sudo mkdir -p "$REMOTE_DIR/nginx/conf.d" \
                         "$REMOTE_DIR/certbot/config" \
                         "$REMOTE_DIR/certbot/www" \
                         "$REMOTE_DIR/certbot/logs"

            # .env (인용 heredoc으로 원격 확장 방지)
            sudo tee "$REMOTE_DIR/.env" >/dev/null <<'EOT'
            DB_NAME=${{ secrets.DB_NAME }}
            DB_USERNAME=${{ secrets.DB_USERNAME }}
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            DB_PORT=${{ secrets.DB_PORT }}
            DOCKER_HUB_USERNAME=${{ secrets.DOCKER_HUB_USERNAME }}
            DOCKER_HUB_ACCESS_TOKEN=${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}
            SPRING_SECURITY_USER_NAME=${{ secrets.SPRING_SECURITY_USER_NAME }}
            SPRING_SECURITY_USER_PASSWORD=${{ secrets.SPRING_SECURITY_USER_PASSWORD }}
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            GMAIL_USERNAME=${{ secrets.GMAIL_USERNAME }}
            GMAIL_APP_PASSWORD=${{ secrets.GMAIL_APP_PASSWORD }}
            API_KEY=${{ secrets.API_KEY }}
            API_URL=${{ secrets.API_URL }}
            BUCKET=${{ secrets.BUCKET }}
            LOCATION=${{ secrets.LOCATION }}
            PROJECT_ID=${{ secrets.PROJECT_ID }}
            GCP_JSON_FILE=${{ secrets.GCP_JSON_FILE }}
            GOOGLE_APPLICATION_CREDENTIALS=/secrets/gcp_service_account.json
            DOMAIN=${{ env.DOMAIN }}
            LETSENCRYPT_EMAIL=${{ env.LETSENCRYPT_EMAIL }}
            HOST_GCP_JSON_PATH=${{ env.REMOTE_DIR }}/gcp_service_account.json
            EOT
          EOF

      # 업로드는 /tmp → sudo mv (권한 안전)
      - name: Upload docker-compose.yml via /tmp
        run: |
          scp -o StrictHostKeyChecking=no docker-compose.yml "$REMOTE_HOST":/tmp/docker-compose.yml
          ssh "$REMOTE_HOST" "sudo mv /tmp/docker-compose.yml '${{ env.REMOTE_DIR }}/docker-compose.yml'"

      - name: Upload NGINX templates via /tmp
        run: |
          scp -o StrictHostKeyChecking=no nginx/default.http.conf.template  "$REMOTE_HOST":/tmp/default.http.conf.template
          scp -o StrictHostKeyChecking=no nginx/default.https.conf.template "$REMOTE_HOST":/tmp/default.https.conf.template
          ssh "$REMOTE_HOST" "
            sudo mv /tmp/default.http.conf.template  '${{ env.REMOTE_DIR }}/nginx/default.http.conf.template';
            sudo mv /tmp/default.https.conf.template '${{ env.REMOTE_DIR }}/nginx/default.https.conf.template';
          "

      # (옵션) GCP 키 업로드: /tmp → sudo mv
      - name: Upload GCP Service Account (optional)
        env:
          GCP_SA: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}
        run: |
          set -euo pipefail
          if [ -z "${GCP_SA:-}" ]; then
            echo "GCP_SERVICE_ACCOUNT_KEY not set. Skipping."
            exit 0
          fi
          if printf '%s' "$GCP_SA" | tr -d '\n' | base64 -d >/dev/null 2>&1; then
            printf '%s' "$GCP_SA" | tr -d '\n' | base64 -d > gcp.json
          else
            printf '%s' "$GCP_SA" > gcp.json
          fi
          scp -o StrictHostKeyChecking=no gcp.json "$REMOTE_HOST":/tmp/gcp.json
          ssh "$REMOTE_HOST" "sudo mv /tmp/gcp.json '${{ env.REMOTE_DIR }}/gcp_service_account.json'"
          rm -f gcp.json

      # 퓨니코드 계산 (표준 idna 코덱 사용)
      - name: Compute Punycode (apex & www)
        id: puny
        env:
          RAW_DOMAIN: ${{ env.DOMAIN }}
          RAW_WWW:    ${{ env.WWW_DOMAIN }}
        run: |
          set -e
          D_ASCII=$(python3 - <<'PY'
          import os
          print(os.environ['RAW_DOMAIN'].encode('idna').decode())
          PY
          )
          W_ASCII=$(python3 - <<'PY'
          import os
          print(os.environ['RAW_WWW'].encode('idna').decode())
          PY
          )
          {
            echo "D_ASCII=$D_ASCII"
            echo "W_ASCII=$W_ASCII"
          } >> "$GITHUB_OUTPUT"
          echo "Apex: $D_ASCII"
          echo "WWW : $W_ASCII"

      # 1) HTTP 기동 (Punycode로 conf 생성)
      - name: Start stack (HTTP only)
        run: |
          ssh "$REMOTE_HOST" \
            "DOMAIN_ASCII='${{ steps.puny.outputs.D_ASCII }}' WWW_ASCII='${{ steps.puny.outputs.W_ASCII }}' bash -s" <<'EOSSH'
            set -euo pipefail
            cd '${{ env.REMOTE_DIR }}'

            DOMAIN="$DOMAIN_ASCII" WWW_DOMAIN="$WWW_ASCII" \
              envsubst '\$DOMAIN,\$WWW_DOMAIN' < nginx/default.http.conf.template \
              | sudo tee nginx/conf.d/default.conf >/dev/null

            sudo docker compose down --remove-orphans || true
            sudo docker compose pull || true
            sudo docker compose up -d nginx backend frontend redis
          EOSSH

      - name: Wait for HTTP (apex punycode)
        run: |
          HOST='${{ steps.puny.outputs.D_ASCII }}'
          for i in $(seq 1 24); do
            if curl -fsS -m 5 -o /dev/null "http://$HOST"; then
              echo "HTTP OK: $HOST"; exit 0
            fi
            echo "...waiting HTTP ($i/24)"; sleep 5
          done
          exit 1

      # (선택) ACME 프리플라이트: 토큰 파일로 HTTP-01 도달 확인
      - name: ACME preflight (HTTP-01 reachability)
        run: |
          set -euo pipefail
          TOKEN="$(openssl rand -hex 16)"

          # 원격에 토큰 생성
          ssh "$REMOTE_HOST" "
            set -euo pipefail
            REMOTE_DIR='${{ env.REMOTE_DIR }}'
            sudo mkdir -p \"\$REMOTE_DIR/certbot/www/.well-known/acme-challenge\"
            echo \"$TOKEN\" | sudo tee \"\$REMOTE_DIR/certbot/www/.well-known/acme-challenge/$TOKEN\" >/dev/null
          "

          for host in "${{ steps.puny.outputs.D_ASCII }}" "${{ steps.puny.outputs.W_ASCII }}"; do
            echo "Check: http://$host/.well-known/acme-challenge/$TOKEN"
            body="$(curl -fsS -m 8 "http://$host/.well-known/acme-challenge/$TOKEN" || true)"
            if [ "$body" != "$TOKEN" ]; then
              echo "❌ ACME path unreachable for $host"
              echo "   Expected: $TOKEN"
              echo "   Got: ${body:0:120}..."
              exit 1
            else
              echo "✅ OK for $host"
            fi
          done

      # 2) 인증서 발급/갱신 (entrypoint override + Punycode)
      - name: Issue/Renew SSL via certbot
        run: |
          ssh "$REMOTE_HOST" \
            "DOMAIN_ASCII='${{ steps.puny.outputs.D_ASCII }}' WWW_ASCII='${{ steps.puny.outputs.W_ASCII }}' bash -s" <<'EOSSH'
            set -euo pipefail
            cd '${{ env.REMOTE_DIR }}'

            sudo docker compose run --rm --entrypoint certbot certbot \
              certonly \
              --webroot -w /var/www/certbot \
              --non-interactive --keep-until-expiring \
              --email '${{ env.LETSENCRYPT_EMAIL }}' \
              -d "$DOMAIN_ASCII" -d "$WWW_ASCII" \
              --agree-tos --no-eff-email --rsa-key-size 4096
          EOSSH

      # 3) HTTPS 전환 & 리로드 (Punycode로 conf 생성)
      - name: Apply HTTPS config & reload nginx
        run: |
          ssh "$REMOTE_HOST" \
            "DOMAIN_ASCII='${{ steps.puny.outputs.D_ASCII }}' WWW_ASCII='${{ steps.puny.outputs.W_ASCII }}' bash -s" <<'EOSSH'
            set -euo pipefail
            cd '${{ env.REMOTE_DIR }}'

            DOMAIN="$DOMAIN_ASCII" WWW_DOMAIN="$WWW_ASCII" \
              envsubst '\$DOMAIN,\$WWW_DOMAIN' < nginx/default.https.conf.template \
              | sudo tee nginx/conf.d/default.conf >/dev/null

            sudo docker compose exec -T nginx nginx -t
            sudo docker compose exec -T nginx nginx -s reload
          EOSSH

      # 4-1) 서버 내부에서 HTTPS 자체검증 (방화벽/외부 라우팅 이슈와 무관)
      - name: Remote self-check HTTPS
        run: |
          ssh "$REMOTE_HOST" \
            "DOMAIN_ASCII='${{ steps.puny.outputs.D_ASCII }}' WWW_ASCII='${{ steps.puny.outputs.W_ASCII }}' bash -s" <<'EOSSH'
            set -euo pipefail
            for h in "$DOMAIN_ASCII" "$WWW_ASCII"; do
              echo "Remote curl https://$h"
              curl -fsS -m 8 -o /dev/null "https://$h"
              echo "OK: $h"
            done
          EOSSH

      # 4-2) 러너에서 서버 공인 IPv4로 SNI 고정 검증 (DNS 캐시/경로 차이 무시)
      - name: Verify HTTPS from runner via fixed IP (SNI/Host forced)
        run: |
          set -e
          for host in "${{ steps.puny.outputs.D_ASCII }}" "${{ steps.puny.outputs.W_ASCII }}"; do
            echo "Runner check: https://$host via ${{ env.REMOTE_IP }}"
            for i in $(seq 1 15); do
              if curl -fsS -m 8 --resolve "$host:443:${{ env.REMOTE_IP }}" "https://$host" -o /dev/null; then
                echo "HTTPS OK (runner via fixed IP): $host"; break
              fi
              [ "$i" -eq 15 ] && { echo "Runner check failed for $host"; exit 1; }
              echo "...retry $i/15"; sleep 2
            done
          done

      - name: Prune old images
        run: ssh "$REMOTE_HOST" "sudo docker image prune -f --filter 'until=24h' || true"
