name: Backend & Frontend & NGINX CD (Auto-SSL)

on:
  push: { branches: [ dev ] }
  workflow_dispatch:

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}

      - name: Build & Push Backend
        run: |
          docker build -t ${{ secrets.DOCKER_HUB_USERNAME }}/backend:latest -f dockerfile .
          docker push ${{ secrets.DOCKER_HUB_USERNAME }}/backend:latest

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    env:
      DOMAIN:            ${{ secrets.DOMAIN }}
      WWW_DOMAIN:        www.${{ secrets.DOMAIN }}
      LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}
      REMOTE_DIR:        /home/ubuntu/app
      REMOTE_HOST:       ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }}
      REMOTE_IP:         ${{ secrets.SERVER_IP }}

    steps:
      - uses: actions/checkout@v4

      # SSH 준비
      - name: Set up SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SERVER_SSH_KEY }}

      - name: Add host key
        run: ssh-keyscan -H ${{ secrets.SERVER_IP }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Test SSH
        run: ssh -o ConnectTimeout=10 "$REMOTE_HOST" "echo OK"

      # 원격 docker compose v2 보장
      - name: Ensure docker compose v2 on remote
        continue-on-error: true
        run: |
          ssh "$REMOTE_HOST" <<'EOSSH'
            set -Eeuo pipefail
            if sudo docker compose version >/dev/null 2>&1; then
              echo "docker compose v2 already present"
              exit 0
            fi
            sudo apt-get update -y
            if ! sudo apt-get install -y docker-compose-plugin; then
              sudo apt-get install -y curl
              ARCH="$(uname -m)"
              case "$ARCH" in
                x86_64|amd64) ARCH="x86_64" ;;
                aarch64|arm64) ARCH="aarch64" ;;
                *) ARCH="x86_64" ;;
              esac
              sudo install -m 0755 -d /usr/local/lib/docker/cli-plugins
              sudo curl -fsSL "https://github.com/docker/compose/releases/download/v2.30.3/docker-compose-linux-$ARCH" \
                -o /usr/local/lib/docker/cli-plugins/docker-compose
              sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
            fi
            sudo docker compose version
            echo "docker compose v2 installed"
          EOSSH

      # Docker 데몬 기동 보장
      - name: Ensure Docker service is running
        run: |
          ssh "$REMOTE_HOST" <<'EOSSH'
            set -euo pipefail
            sudo systemctl enable --now docker || sudo service docker start
            sudo docker info >/dev/null
          EOSSH

      # 기존 컨테이너 정리 (선택적)
      - name: Clean up old containers
        continue-on-error: true
        run: |
          ssh "$REMOTE_HOST" <<'EOSSH'
            cd '${{ env.REMOTE_DIR }}' || exit 0
            sudo docker compose down --remove-orphans || true
            sudo docker system prune -f || true
          EOSSH

      # 필수 디렉터리 + .env 생성
      - name: Prepare remote dirs & .env
        run: |
          ssh "$REMOTE_HOST" <<'EOSSH'
            set -euo pipefail
            REMOTE_DIR='${{ env.REMOTE_DIR }}'

            # envsubst 설치
            if ! command -v envsubst >/dev/null 2>&1; then
              sudo apt-get update -y
              sudo apt-get install -y gettext-base
            fi

            # 디렉터리 생성
            sudo mkdir -p "$REMOTE_DIR/nginx/conf.d" \
                         "$REMOTE_DIR/certbot/config" \
                         "$REMOTE_DIR/certbot/www" \
                         "$REMOTE_DIR/certbot/logs"

            # 기존 .env 파일 백업 (있다면)
            if sudo test -f "$REMOTE_DIR/.env"; then
              sudo cp "$REMOTE_DIR/.env" "$REMOTE_DIR/.env.backup.$(date +%Y%m%d_%H%M%S)"
            fi

            # .env 파일 생성 (heredoc 구분자를 더 명확하게)
            sudo bash -c "cat > '$REMOTE_DIR/.env'" <<'ENV_CONTENT'
            DB_NAME=${{ secrets.DB_NAME }}
            DB_USERNAME=${{ secrets.DB_USERNAME }}
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            DB_PORT=${{ secrets.DB_PORT }}
            DOCKER_HUB_USERNAME=${{ secrets.DOCKER_HUB_USERNAME }}
            DOCKER_HUB_ACCESS_TOKEN=${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}
            SPRING_SECURITY_USER_NAME=${{ secrets.SPRING_SECURITY_USER_NAME }}
            SPRING_SECURITY_USER_PASSWORD=${{ secrets.SPRING_SECURITY_USER_PASSWORD }}
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            GMAIL_USERNAME=${{ secrets.GMAIL_USERNAME }}
            GMAIL_APP_PASSWORD=${{ secrets.GMAIL_APP_PASSWORD }}
            API_KEY=${{ secrets.API_KEY }}
            API_URL=${{ secrets.API_URL }}
            BUCKET=${{ secrets.BUCKET }}
            LOCATION=${{ secrets.LOCATION }}
            PROJECT_ID=${{ secrets.PROJECT_ID }}
            GCP_JSON_FILE=${{ secrets.GCP_JSON_FILE }}
            GOOGLE_APPLICATION_CREDENTIALS=/secrets/gcp_service_account.json
            DOMAIN=${{ env.DOMAIN }}
            LETSENCRYPT_EMAIL=${{ env.LETSENCRYPT_EMAIL }}
            HOST_GCP_JSON_PATH=${{ env.REMOTE_DIR }}/gcp_service_account.json
            REMOTE_DIR=${{ env.REMOTE_DIR }}
            ENV_CONTENT

            # .env 파일 권한 설정 (별도 명령으로)
            sudo chmod 600 "$REMOTE_DIR/.env"
            
            # .env 파일 검증
            echo "Validating .env file..."
            if sudo test -s "$REMOTE_DIR/.env"; then
              echo "✅ .env file created successfully"
              echo "File size: $(sudo wc -l < "$REMOTE_DIR/.env") lines"
            else
              echo "❌ .env file is empty or not created"
              exit 1
            fi
          EOSSH

      # 설정 파일들 업로드
      - name: Upload configuration files
        run: |
          # docker-compose.yml 업로드
          scp -o StrictHostKeyChecking=no docker-compose.yml "$REMOTE_HOST":/tmp/docker-compose.yml
          ssh "$REMOTE_HOST" "sudo mv /tmp/docker-compose.yml '${{ env.REMOTE_DIR }}/docker-compose.yml'"

          # NGINX 템플릿 업로드
          scp -o StrictHostKeyChecking=no nginx/default.http.conf.template  "$REMOTE_HOST":/tmp/default.http.conf.template
          scp -o StrictHostKeyChecking=no nginx/default.https.conf.template "$REMOTE_HOST":/tmp/default.https.conf.template
          ssh "$REMOTE_HOST" "
            sudo mv /tmp/default.http.conf.template  '${{ env.REMOTE_DIR }}/nginx/default.http.conf.template';
            sudo mv /tmp/default.https.conf.template '${{ env.REMOTE_DIR }}/nginx/default.https.conf.template';
          "

      # GCP 키 업로드 (옵션)
      - name: Upload GCP Service Account (optional)
        env:
          GCP_SA: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}
        run: |
          set -euo pipefail
          if [ -z "${GCP_SA:-}" ]; then
            echo "GCP_SERVICE_ACCOUNT_KEY not set. Skipping."
            exit 0
          fi
          if printf '%s' "$GCP_SA" | tr -d '\n' | base64 -d >/dev/null 2>&1; then
            printf '%s' "$GCP_SA" | tr -d '\n' | base64 -d > gcp.json
          else
            printf '%s' "$GCP_SA" > gcp.json
          fi
          scp -o StrictHostKeyChecking=no gcp.json "$REMOTE_HOST":/tmp/gcp.json
          ssh "$REMOTE_HOST" "sudo mv /tmp/gcp.json '${{ env.REMOTE_DIR }}/gcp_service_account.json'"
          rm -f gcp.json

      # Punycode 계산
      - name: Compute Punycode (apex & www)
        id: puny
        env:
          RAW_DOMAIN: ${{ env.DOMAIN }}
          RAW_WWW:    ${{ env.WWW_DOMAIN }}
        run: |
          set -e
          D_ASCII=$(python3 - <<'PY'
          import os
          print(os.environ['RAW_DOMAIN'].encode('idna').decode())
          PY
          )
          W_ASCII=$(python3 - <<'PY'
          import os
          print(os.environ['RAW_WWW'].encode('idna').decode())
          PY
          )
          {
            echo "D_ASCII=$D_ASCII"
            echo "W_ASCII=$W_ASCII"
          } >> "$GITHUB_OUTPUT"
          echo "Apex: $D_ASCII"
          echo "WWW : $W_ASCII"

      # 최신 이미지 pull
      - name: Pull latest images
        run: |
          ssh "$REMOTE_HOST" <<'EOSSH'
            cd '${{ env.REMOTE_DIR }}'
            sudo docker compose pull backend frontend || true
          EOSSH

      # 1) HTTP 모드로 스택 시작
      - name: Start stack (HTTP only)
        run: |
          ssh "$REMOTE_HOST" \
            "DOMAIN_ASCII='${{ steps.puny.outputs.D_ASCII }}' WWW_ASCII='${{ steps.puny.outputs.W_ASCII }}' bash -s" <<'EOSSH'
            set -euo pipefail
            cd '${{ env.REMOTE_DIR }}'

            # HTTP 설정 생성
            DOMAIN="$DOMAIN_ASCII" WWW_DOMAIN="$WWW_ASCII" \
              envsubst '\$DOMAIN,\$WWW_DOMAIN' < nginx/default.http.conf.template \
              | sudo tee nginx/conf.d/default.conf >/dev/null

            # 컨테이너 시작 (순차적으로)
            sudo docker compose up -d redis db
            sleep 10
            sudo docker compose up -d backend
            sleep 10
            sudo docker compose up -d frontend nginx
          EOSSH

      # 헬스체크 대기
      - name: Wait for services to be healthy
        run: |
          ssh "$REMOTE_HOST" <<'EOSSH'
            cd '${{ env.REMOTE_DIR }}'
            echo "Waiting for services..."
            for i in $(seq 1 30); do
              if sudo docker compose ps --format json | jq -r '.[] | select(.Health == "healthy" or .Health == "") | .Name' | grep -q "ctf-"; then
                echo "Services are ready"
                sudo docker compose ps
                break
              fi
              echo "Waiting for services... ($i/30)"
              sleep 10
            done
          EOSSH

      - name: Wait for HTTP (apex punycode)
        run: |
          HOST='${{ steps.puny.outputs.D_ASCII }}'
          for i in $(seq 1 24); do
            if curl -fsS -m 5 -o /dev/null "http://$HOST"; then
              echo "HTTP OK: $HOST"; exit 0
            fi
            echo "...waiting HTTP ($i/24)"; sleep 5
          done
          echo "HTTP check failed. Checking logs..."
          ssh "$REMOTE_HOST" "cd '${{ env.REMOTE_DIR }}' && sudo docker compose logs nginx backend frontend"
          exit 1

      # ACME preflight (개선된 오류 처리)
      - name: ACME preflight (HTTP-01 reachability)
        run: |
          set -euo pipefail
          TOKEN="$(openssl rand -hex 16)"

          # 토큰 파일 생성
          ssh "$REMOTE_HOST" "
            set -euo pipefail
            REMOTE_DIR='${{ env.REMOTE_DIR }}'
            sudo mkdir -p \"\$REMOTE_DIR/certbot/www/.well-known/acme-challenge\"
            echo \"$TOKEN\" | sudo tee \"\$REMOTE_DIR/certbot/www/.well-known/acme-challenge/$TOKEN\" >/dev/null
          "

          # 각 도메인에 대해 ACME 경로 테스트
          for host in "${{ steps.puny.outputs.D_ASCII }}" "${{ steps.puny.outputs.W_ASCII }}"; do
            echo "Testing ACME challenge for: $host"
            URL="http://$host/.well-known/acme-challenge/$TOKEN"
            
            body=""
            for i in $(seq 1 5); do
              if body="$(curl -fsS -m 10 "$URL" 2>/dev/null)"; then
                break
              fi
              echo "Retry $i/5 for $host..."
              sleep 3
            done

            if [ "$body" != "$TOKEN" ]; then
              echo "❌ ACME path unreachable for $host"
              echo "URL: $URL"
              echo "Expected: $TOKEN"
              echo "Got: ${body:-<empty response>}"
              echo "--- NGINX Logs ---"
              ssh "$REMOTE_HOST" "cd '${{ env.REMOTE_DIR }}' && sudo docker compose logs --tail=50 nginx"
              exit 1
            else
              echo "✅ ACME OK for $host"
            fi
          done

      # SSL 인증서 발급/갱신
      - name: Issue/Renew SSL via certbot
        run: |
          ssh "$REMOTE_HOST" \
            "DOMAIN_ASCII='${{ steps.puny.outputs.D_ASCII }}' WWW_ASCII='${{ steps.puny.outputs.W_ASCII }}' bash -s" <<'EOSSH'
            set -euo pipefail
            cd '${{ env.REMOTE_DIR }}'

            echo "Requesting SSL certificate for $DOMAIN_ASCII and $WWW_ASCII"
            
            sudo docker compose run --rm --entrypoint certbot certbot \
              certonly \
              --webroot -w /var/www/certbot \
              --non-interactive --keep-until-expiring \
              --email '${{ env.LETSENCRYPT_EMAIL }}' \
              -d "$DOMAIN_ASCII" -d "$WWW_ASCII" \
              --agree-tos --no-eff-email --rsa-key-size 4096 \
              --verbose

            # 인증서 파일 확인
            if sudo test -f "/home/ubuntu/app/certbot/config/live/$DOMAIN_ASCII/fullchain.pem"; then
              echo "✅ Certificate issued successfully"
              sudo ls -la "/home/ubuntu/app/certbot/config/live/$DOMAIN_ASCII/"
            else
              echo "❌ Certificate not found"
              exit 1
            fi
          EOSSH

      # HTTPS 설정 적용
      - name: Apply HTTPS config & reload nginx
        run: |
          ssh "$REMOTE_HOST" \
            "DOMAIN_ASCII='${{ steps.puny.outputs.D_ASCII }}' WWW_ASCII='${{ steps.puny.outputs.W_ASCII }}' bash -s" <<'EOSSH'
            set -euo pipefail
            cd '${{ env.REMOTE_DIR }}'

            # HTTPS 설정 생성
            DOMAIN="$DOMAIN_ASCII" WWW_DOMAIN="$WWW_ASCII" \
              envsubst '\$DOMAIN,\$WWW_DOMAIN' < nginx/default.https.conf.template \
              | sudo tee nginx/conf.d/default.conf >/dev/null

            echo "Testing NGINX configuration..."
            if ! sudo docker compose exec -T nginx nginx -t; then
              echo "❌ NGINX config test failed"
              echo "--- NGINX Config ---"
              sudo docker compose exec -T nginx cat /etc/nginx/conf.d/default.conf
              exit 1
            fi

            echo "Reloading NGINX..."
            sudo docker compose exec -T nginx nginx -s reload
            echo "✅ NGINX reloaded with HTTPS config"
          EOSSH

      # HTTPS 검증
      - name: Verify HTTPS deployment
        run: |
          # 서버 내부 검증
          ssh "$REMOTE_HOST" \
            "DOMAIN_ASCII='${{ steps.puny.outputs.D_ASCII }}' WWW_ASCII='${{ steps.puny.outputs.W_ASCII }}' bash -s" <<'EOSSH'
            set -euo pipefail
            for h in "$DOMAIN_ASCII" "$WWW_ASCII"; do
              echo "Internal HTTPS check: $h"
              if curl -fsS -m 10 -o /dev/null "https://$h"; then
                echo "✅ Internal HTTPS OK: $h"
              else
                echo "❌ Internal HTTPS failed: $h"
                exit 1
              fi
            done
          EOSSH

          # 외부 검증 (GitHub Runner에서)
          for host in "${{ steps.puny.outputs.D_ASCII }}" "${{ steps.puny.outputs.W_ASCII }}"; do
            echo "External HTTPS check: $host"
            for i in $(seq 1 15); do
              if curl -fsS -m 10 --resolve "$host:443:${{ env.REMOTE_IP }}" "https://$host" -o /dev/null; then
                echo "✅ External HTTPS OK: $host"
                break
              fi
              if [ "$i" -eq 15 ]; then
                echo "❌ External HTTPS failed for $host after 15 attempts"
                # 디버깅 정보 출력
                ssh "$REMOTE_HOST" "cd '${{ env.REMOTE_DIR }}' && sudo docker compose logs --tail=20 nginx"
                exit 1
              fi
              echo "Retry $i/15 for $host..."
              sleep 4
            done
          done

      # 리소스 정리
      - name: Cleanup old resources
        continue-on-error: true
        run: |
          ssh "$REMOTE_HOST" <<'EOSSH'
            # 오래된 이미지 정리
            sudo docker image prune -f --filter 'until=24h' || true
            
            # 사용하지 않는 볼륨 정리
            sudo docker volume prune -f || true
            
            # 임시 파일 정리
            sudo rm -f /tmp/docker-compose.yml /tmp/*.template /tmp/gcp.json || true
          EOSSH

      # 최종 상태 확인
      - name: Final deployment status
        run: |
          ssh "$REMOTE_HOST" <<'EOSSH'
            cd '${{ env.REMOTE_DIR }}'
            echo "=== Final Status ==="
            sudo docker compose ps
            echo ""
            echo "=== Resource Usage ==="
            sudo docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}"
            echo ""
            echo "✅ Deployment completed successfully!"
          EOSSH